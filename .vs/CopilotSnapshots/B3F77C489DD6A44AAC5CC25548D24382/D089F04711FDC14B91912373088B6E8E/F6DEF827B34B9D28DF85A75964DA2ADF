#include "App.h"

#include <cwchar>

// Constructor: initialize internal handles to null.
App::App()
    : m_hInstance(nullptr), m_hWnd(nullptr), m_hButton(nullptr), m_hEdit(nullptr), m_hReceiveEdit(nullptr)
{
}

// Destructor: destroy the main window if created and unregister the window class.
App::~App()
{
    if (m_hWnd)
    {
        DestroyWindow(m_hWnd);
        m_hWnd = nullptr;
    }

    if (m_hInstance)
    {
        UnregisterClassW(m_windowClassName, m_hInstance);
        m_hInstance = nullptr;
    }
}

// Initialize: register the window class, create the main window and child controls (button).
// Returns true on success, false on failure.
bool App::Initialize(HINSTANCE hInstance, int nCmdShow)
{
    m_hInstance = hInstance;

    WNDCLASSEXW wc = {};
    wc.cbSize = sizeof(wc);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = App::WindowProc;
    wc.hInstance = hInstance;
    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);
    wc.hbrBackground = reinterpret_cast<HBRUSH>(COLOR_WINDOW + 1);
    wc.lpszClassName = m_windowClassName;

    if (!RegisterClassExW(&wc))
    {
        return false;
    }

    int width = 800;
    int height = 600;
    DWORD style = WS_OVERLAPPEDWINDOW;

    RECT wr = { 0, 0, width, height };
    AdjustWindowRect(&wr, style, FALSE);

    m_hWnd = CreateWindowExW(
        0,
        m_windowClassName,
        m_windowTitle,
        style,
        CW_USEDEFAULT, CW_USEDEFAULT,
        wr.right - wr.left, wr.bottom - wr.top,
        nullptr,
        nullptr,
        hInstance,
        nullptr);

    if (!m_hWnd)
    {
        UnregisterClassW(m_windowClassName, hInstance);
        return false;
    }

    // Store the pointer to this instance in GWLP_USERDATA so WindowProc can access it if needed
    SetWindowLongPtrW(m_hWnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this));

    // Get client rect to position controls
    RECT clientRect = {};
    GetClientRect(m_hWnd, &clientRect);
    int clientWidth = clientRect.right - clientRect.left;
    int clientHeight = clientRect.bottom - clientRect.top;

    // Create an edit control for text entry (moved down to make room for the label above)
    int topEditX = 10;
    int topEditY = 40;
    int candidateWidth = clientWidth - 160;
    int topEditWidth = (candidateWidth > 200) ? candidateWidth : 200;
    m_hEdit = CreateWindowExW(
        WS_EX_CLIENTEDGE,
        L"EDIT",
        nullptr,
        WS_CHILD | WS_VISIBLE | ES_LEFT | ES_AUTOHSCROLL,
        topEditX, topEditY,
        topEditWidth, 24,
        m_hWnd,
        reinterpret_cast<HMENU>(static_cast<INT_PTR>(EDIT_ID)),
        hInstance,
        nullptr);

    // Create a button to submit the text from the edit control (moved down to align with the edit)
    int buttonX = topEditX + topEditWidth + 10;
    m_hButton = CreateWindowExW(
        0,
        L"BUTTON",
        L"Submit",
        WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON,
        buttonX, topEditY - 2,
        120, 30,
        m_hWnd,
        reinterpret_cast<HMENU>(static_cast<INT_PTR>(BUTTON_ID)),
        hInstance,
        nullptr);

    // Create a receive-only edit control at the bottom for data from another application
    int recvHeight = 24;
    int recvY = clientHeight - recvHeight - 10;
    int recvWidthCandidate = clientWidth - 20;
    int recvWidth = (recvWidthCandidate > 200) ? recvWidthCandidate : 200;
    m_hReceiveEdit = CreateWindowExW(
        WS_EX_CLIENTEDGE,
        L"EDIT",
        nullptr,
        WS_CHILD | WS_VISIBLE | ES_LEFT | ES_AUTOHSCROLL | ES_READONLY,
        10, recvY,
        recvWidth, recvHeight,
        m_hWnd,
        reinterpret_cast<HMENU>(static_cast<INT_PTR>(RECEIVE_EDIT_ID)),
        hInstance,
        nullptr);

    ShowWindow(m_hWnd, nCmdShow);
    UpdateWindow(m_hWnd);

    return true;
}

// Run: main message loop. Processes messages until WM_QUIT is received and returns exit code.
int App::Run()
{
    MSG msg;
    while (GetMessageW(&msg, nullptr, 0, 0) > 0)
    {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }
    return static_cast<int>(msg.wParam);
}

// WindowProc: static window procedure. Dispatches messages to the App instance stored in
// GWLP_USERDATA and handles WM_COMMAND (button clicks), WM_PAINT and WM_DESTROY.
LRESULT CALLBACK App::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;

    case WM_SIZE:
    {
        // Reposition controls when the window is resized
        int newWidth = LOWORD(lParam);
        int newHeight = HIWORD(lParam);
        App* pThis = reinterpret_cast<App*>(GetWindowLongPtrW(hWnd, GWLP_USERDATA));
        if (pThis)
        {
            // Top edit and button
            int topEditX = 10;
            int topEditY = 40;
            int candidateWidth = newWidth - 160;
            int topEditWidth = (candidateWidth > 200) ? candidateWidth : 200;
            if (pThis->m_hEdit)
                MoveWindow(pThis->m_hEdit, topEditX, topEditY, topEditWidth, 24, TRUE);

            int buttonX = topEditX + topEditWidth + 10;
            if (pThis->m_hButton)
                MoveWindow(pThis->m_hButton, buttonX, topEditY - 2, 120, 30, TRUE);

            // Receive edit at bottom
            int recvHeight = 24;
            int recvY = newHeight - recvHeight - 10;
            int recvWidthCandidate = newWidth - 20;
            int recvWidth = (recvWidthCandidate > 200) ? recvWidthCandidate : 200;
            if (pThis->m_hReceiveEdit)
                MoveWindow(pThis->m_hReceiveEdit, 10, recvY, recvWidth, recvHeight, TRUE);
        }
        return 0;
    }

    case WM_COMMAND:
    {
        int id = LOWORD(wParam);
        int code = HIWORD(wParam);
        App* pThis = reinterpret_cast<App*>(GetWindowLongPtrW(hWnd, GWLP_USERDATA));
        if (pThis)
        {
            if (id == BUTTON_ID && code == BN_CLICKED)
            {
                pThis->OnButtonClicked();
                return 0;
            }
        }
        break;
    }

    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hWnd, &ps);
        // Draw the label above the top edit control
        const wchar_t* text = L"Enter text below and press Submit";
        TextOutW(hdc, 10, 12, text, static_cast<int>(std::wcslen(text)));

        // Draw a label above the receive-only edit control at the bottom
        RECT clientRect;
        GetClientRect(hWnd, &clientRect);
        int clientHeight = clientRect.bottom - clientRect.top;
        int recvHeight = 24;
        int recvY = clientHeight - recvHeight - 10;
        int labelY = recvY - 18; // place the label a bit above the receive control
        const wchar_t* recvLabel = L"Received data:";
        TextOutW(hdc, 10, labelY, recvLabel, static_cast<int>(std::wcslen(recvLabel)));

        EndPaint(hWnd, &ps);
        return 0;
    }

    }

    return DefWindowProcW(hWnd, uMsg, wParam, lParam);
}

// OnButtonClicked: invoked when the button is clicked. Reads text from the edit control and
// displays it in a message box.
void App::OnButtonClicked()
{
    if (!m_hEdit)
        return;

    const int bufSize = 1024;
    wchar_t buffer[bufSize] = {};
    int len = GetWindowTextW(m_hEdit, buffer, bufSize);
    if (len > 0)
    {
        MessageBoxW(m_hWnd, buffer, L"Submitted Text", MB_OK | MB_ICONINFORMATION);
    }
    else
    {
        MessageBoxW(m_hWnd, L"No text entered.", L"Info", MB_OK | MB_ICONINFORMATION);
    }
}

// SetReceivedText: set the text shown in the receive-only edit control (used by other apps to send data).
void App::SetReceivedText(const wchar_t* text)
{
    if (!m_hReceiveEdit)
        return;

    SetWindowTextW(m_hReceiveEdit, text ? text : L"");
}

// wWinMain: application entry point. Creates the App instance, initializes it, and runs the message loop.
int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE /*hPrevInstance*/, PWSTR /*pCmdLine*/, int nCmdShow)
{
    App app;
    if (!app.Initialize(hInstance, nCmdShow))
    {
        return -1;
    }

    return app.Run();
}
